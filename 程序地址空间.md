@[TOC](目录)

### 程序地址空间

* 堆是堆，栈是栈，堆栈等于栈
* 程序地址空间--->不是内存--->是**进程虚拟地址空间**

我们来看一个现象：

![image-20220320231657986](C:\Users\yangyr0206\AppData\Roaming\Typora\typora-user-images\image-20220320231657986.png)首先我们知道，改变子进程的值不会影响父进程的值(因为有写实拷贝)，但是我们发现一个现象：父子进程的g_val的值是不同的，可是它们的地址却是相同的----->如果打印出来的地址是物理内存的地址这一现象是不可能存在的，所以这个地址不会是物理地址，这个地址是**虚拟地址**

#### 进程地址空间概念

* 每一个进程都有一个地址空间，都认为自己在独占物理内存

* 在内核中,地址空间就是一个数据类型,可以                                                                                                                                                                                                                                                                                                                                                                    用其来定义具体进程的地址空间变量

  ```c++
  struct mm_struct{
  //进程地址空间(32位-->4G)
      unsigned int code_start;
      unsigned int code_end;
      
      unsigned int init_data_start;
      unsigned int init_data_start;
      
      unsigned int uninit_data_start;
      unsigned int uninit_data_end;
      
      unsigned int heap_start;
      unsigned int heap_end;
      //......
      unsigned int stack_start;
      unsigned int stack_end;
  }//每个进程都认为地址空间的划分是按照4GB空间划分的，换而言之，每个进程都认为自己拥有这4GB
  ```
  
  虚拟空间划分之后，进程还是需要运行代码读取数据所以就需要**页表和MMU(MMU是硬件设备，一般集成在CPU中)**

---

#### 页表

* MMU(内存管理单元)
* 页表 ：简单理解就是这个表的左边是虚拟地址，右边是物理地址
  * 核心工作：将虚拟地址转换成物理地址
  * 页表本质上就是一个映射表(哈希表)
  * 用户在寻址时，使用的是虚拟地址，由操作系统经过页表的映射找到物理地址，进而再去访问代码和数据

**为什么要有地址空间？**

1. 通过添加一层软件层，完成有效的对进程操作内存进行风险管理(权限管理)，本质目的是为了**保护物理内存以及各个进程的数据安全**
2. 将内存申请和内存使用的概念在时间上划分清楚，通过虚拟地址空间，来屏蔽底层申请内存的过程，达到进程读写内存和OS进行内存管理操作，进行软件上面的分离(**基于缺页中断进行物理内存申请**)
3. 站在CPU和应用层的角度，进程可以看做统一使用4GB空间，而且每个空间区域的相对位置，是比较确定的(**也就是程序的代码和数据可以被加载到物理内存的任意位置--->大大的减少内存管理的负担**)

